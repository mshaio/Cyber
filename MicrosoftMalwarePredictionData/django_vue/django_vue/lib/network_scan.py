import os
import re
import urllib.request as urllib2
import json
import codecs

from devices.models import Device
# import sys
# sys.path.append('..')
# from devices.models import Device

class NetworkScanner:
     
     BROADCAST_ADDR = "255"
     SUBNET = "/24"

     def __init__(self, ip_address, port=None):
         self.ip_address = ip_address
         self.port = port


     def get_devices_on_network(self, nmap_options, arp_options):
        """
        Retrieves the devices on the network via NMAP
        Args:
            nmap_options (string): The nmap flags
            arp_options (string): The arp flags

        Returns:
            arp_output (string): Arp output that contains the IPs and MACs
            eg: "? (10.0.0.110) at f0:18:98:e:3e:1c on en0 ifscope permanent [ethernet]
                 ? (10.0.0.118) at 10:30:25:6e:1a:95 on en0 ifscope [ethernet]"
        """
        # threading.Timer(12.0, get_devices_on_network,(options, ip_address)).start()
        THIRD_OCTET = 3
        first_3_ip_octet = self.ip_address.split(".")[:THIRD_OCTET]
        command = "ping " + first_3_ip_octet[0] + "." + first_3_ip_octet[1] + "." + first_3_ip_octet[2] + "." + NetworkScanner.BROADCAST_ADDR
        process = os.popen(command)
        command = "nmap " + nmap_options + " " + self.ip_address + NetworkScanner.SUBNET
        process = os.popen(command)
        command = "arp " + arp_options #"arp -a -n"
        process = os.popen(command)
        arp_output = str(process.read())[:-1] #Removes the space at the end
        # print(arp_output)
        return arp_output

     def get_correct_index(self, formatted_arp_output):
         """
         Gets the index of the ips that don't return with 'incomplete' from arp -a
         Args:
            formatted_arp_output (list(string)): arp output split by new line
            eg: ['? (10.0.0.1) at 5c:76:95:d2:29:56 on en0 ifscope [ethernet]', 
                '? (10.0.0.96) at e4:e7:49:c4:56:7e on en0 ifscope [ethernet]']

         Returns:
            ip_index (list(int)): Index of ip addresses that don't return 'incomplete' via an arp scan
         """
         ip_index = []
         index = 0
         for i in formatted_arp_output:
             if 'incomplete' not in i:
                 ip_index.append(index)
             index +=1
         return ip_index

     def format_to_get_ip(self, arp_output):
         """
         Formats the arp results to get the IPs. Uses regex to retrieve the content between ().
         Args: 
            arp_output (string): Arp output
         Returns:
            ips (list(string)): The list of ips on the network
            eg: ['10.0.0.1', '10.0.0.110', '10.0.0.118', '10.0.0.153', '10.0.0.255']
         """
         formatted_arp_output = arp_output.splitlines()
         ips = []
         ip_index = self.get_correct_index(formatted_arp_output)
         for i in ip_index:
             #ips.append(re.search('\(([^)]+)', arp_result[i]).groups(1)[0])
             ip_data = re.search('\(([^)]+)', formatted_arp_output[int(i)]) #Get the data between brackets ()
             if 'incomplete' not in ip_data.group(1):
                 ips.append(ip_data.group(1))
         return ips

     def format_to_get_mac(self, arp_output):
         """
         Formats the arp results to get the mac addresses. Uses regex to retrive the content between 'at' and 'on' strings
         Args:
            arp_output (string): Arp output
         Returns:
            macs (list(string)): A list of mac addresses on the network
            eg: ['5c:76:95:d2:29:56', 'f0:18:98:e:3e:1c']
         """
         formatted_arp_output = arp_output.splitlines()
         macs = []
         for i in range(len(formatted_arp_output)):
             mac_data = re.search('at (.*) on', formatted_arp_output[i]) #Gets the string between at and on
             if 'incomplete' not in mac_data.group(1):
                 macs.append(mac_data.group(1))
             # print("mac",macs)
         return macs

     def get_vendor_by_mac(self, mac_addresses):
         """
         Get the vendor from the mac address
         Args:
            mac_addresses (list(string)): A list of mac addresses found on the network
         Returns:
            vendors (list(string)): A list of vendors for the devices on the network
            eg: ['Technicolor CH USA Inc.', 'Apple, Inc.']
         """
         #API base url,you can also use https if you need
         url = "http://macvendors.co/api/"
         #Mac address to lookup vendor from
         #mac_address = "74:E5:43:D2:8A:81"
         vendors = []
         for i in range(len(mac_addresses)):
             request = urllib2.Request(url+mac_addresses[i], headers={'User-Agent' : "API Browser"})
             response = urllib2.urlopen( request )
             #Fix: json object must be str, not 'bytes'
             reader = codecs.getreader("utf-8")
             obj = json.load(reader(response))
             #print(obj)
             if ('company' in obj['result'].keys()):
                 vendors.append(obj['result']['company'])
             else:
                 vendors.append("Not Found")
         return vendors

     @classmethod
     def detect_mobile(cls, ip_addresses):
         """
         Detects if the ip_address corresponds to a mobile device
         Args:
            ip_addresses (list(string)): ip addresses of devices on network
         Returns 
            (list(bool)): 3 lists. Mobile, iphone, Android
            eg: [False, False, True, False, True, False] #Mobile
                [False, False, True, False, True, False] #iphone
                [False, False, False, False, False, False] #Android
         """
         mobile = []
         iphone = []
         android = []
         for ip_address in ip_addresses:
             try:
                command = "nmap --max-rate 100 " + ip_address + " -vv -p 62078"
                process = os.popen(command)
                nmap_output = str(process.read())
                nmap_output = re.search('62078/tcp open  (.*) syn', nmap_output) #Gets the string between 62078/tcp open  and syn
                if nmap_output.group(1) == "iphone-sync":
                    mobile.append(True)
                    iphone.append(True)
                    android.append(False)
                else:
                    iphone.append(False)
             except:
                 mobile.append(False)
                 iphone.append(False)
                 android.append(False)
         return mobile, iphone, android

     def detect_failed_ping(self, ip_address):
         """
         Sometimes arp -a will remember ip addresses that have been disconnected from the network after being established on the network. To ensure only devices
         that are on the network live, ping the device one more time and if it reponds with a 100% packet loss then that means the device is not actually on the
         network.
         Args:
            ip_address (string): ip_address
         Returns:
            ip_address (string): ip_address that has 100% packetloss, ie was on the network as detected by arp -a but no longer on the network
         """
         command = "ping " + ip_address + " -c 1"
         process = os.popen(command)
         ping_output = str(process.read())
         print(ping_output)
         ping_output = re.search('packets received, (.*)% packet loss', ping_output)
         if float(ping_output.group(1)) == 100.0:
             return ip_address
         return None

     def detect_open_common_ports(self, ip_addresses):
         """
         Detects if the common ports are open for the associated ip address. Common ports include: FTP, SSH, SMTP, DNS, HTTP,
         POP3 (110 and 995), NTD, IMAP, HTTPS, SMTPS, CUPS, IMAPS.
         Args:
             ip_addresses (list(string)): ip addresses of devices on network
         Returns:
             common_ports_are_open (list(bool)): A list indicating there are common open ports on the associated ip address
             eg: ['closed/filtered', 'closed/filtered', 'open', 'open', 'closed/filtered', 'open', 'open', 'open']

         Note:
             The function also computes common_ports_info, which is a dictionary containing the port protocol as the key and 
             the port number and status as the value.
             eg: {'ssh': ['22/tcp', 'closed/filtered'], 
                 'telnet': ['23/tcp', 'closed/filtered'], 
                 'domain': ['53/tcp', 'open'], 
                 'http': ['80/tcp', 'open'], 
                 'rpcbind': ['111/tcp', 'closed/filtered'], 
                 'https': ['443/tcp', 'open'], 
                 'http-proxy': ['8080/tcp', 'open'], 
                 'unknown': ['49152/tcp', 'open']}
         """
         common_ports_info = {}
         common_ports_are_open = []
         for ip_address in ip_addresses:
             command = "nmap -F " + ip_address
             process = os.popen(command)
             nmap_output = str(process.read())
             try:
                for i in nmap_output.splitlines()[nmap_output.splitlines().index("PORT      STATE    SERVICE") + 1:-2]:
                    if "open" in i.split(' '):
                        common_ports_info[i.split(' ')[-1]] = [i.split(' ')[0], "open"]
                        common_ports_are_open.append("open")
                    else:
                        common_ports_info[i.split(' ')[-1]] = [i.split(' ')[0], "closed/filtered"]
                        common_ports_are_open.append("closed/filtered")
             except:
                 common_ports_are_open.append("closed/filtered")
                 continue
         
         return common_ports_are_open

     def check_if_identifier_broadcast(self, ip_addresses):
         """
         Checks if the ips addresses contains the identifier address eg: 192.0.0.0 or the broadcast address eg: 192.0.0.255.
         If it does remove them.
         Args:
            ip_addresses (list(string)): ip addresses of devices on network

         Returns:
            valid_ip_addresses (list(string)): ip addresses of devices on network excluding the identifier and broadcast addresses
         """
         valid_ip_addresses = []
         for ip_address in ip_addresses:
            if '255' != ip_address.split('.')[-1] or '0' != ip_address.split('.')[-1]:
                valid_ip_addresses.append(ip_address)
         return valid_ip_addresses

def get_local_ip():
    """
    Find the ip address of the machine running the network scan
    Args: 
        None
    Returns:
        ip_address (string): The ip address of the machine that's running the network scan
    """
    command = "ipconfig getifaddr en0" #Linux is hostname -I
    process = os.popen(command)
    ip_address = str(process.read())[:-1] #Removes the space at the end
    return ip_address



local_device_ip = get_local_ip()
local_scanner = NetworkScanner(get_local_ip())
arp_output = local_scanner.get_devices_on_network("-sn", "-a -n")
ips = local_scanner.format_to_get_ip(arp_output)[:-2]
# ips = local_scanner.check_if_identifier_broadcast(ips)
macs = local_scanner.format_to_get_mac(arp_output)[:-2]
vendors = local_scanner.get_vendor_by_mac(macs)
mobile, iphone, android = NetworkScanner.detect_mobile(ips)
ports_open = local_scanner.detect_open_common_ports(ips)
print(arp_output)
print(ips)
print(macs)
print(vendors)

for i in range(len(ips)):
    device = Device()
    device.ip_address = ips[i]
    device.mac_address = macs[i]
    device.vendor = vendors[i]
    device.mobile = mobile[i]
    device.port = ports_open[i]
    device, created = Device.objects.update_or_create(ip_address=device.ip_address,mac_address=device.mac_address,vendor=device.vendor,mobile=device.mobile,port=device.port)