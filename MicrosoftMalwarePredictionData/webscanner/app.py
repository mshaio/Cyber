#Cyber purpose imports
from tld import get_tld
import socket
import os
import urllib.request
import io
import urllib.request as urllib2
import json
import codecs
import requests
import threading
import time

#Data science imports
import pandas as pd

#Regex import
import re

#Global variable
global temp_ip_list
temp_ip_list = []
global old_ip_list
old_ip_list = []

#Web framework imports
from flask import Flask, render_template
app = Flask(__name__)

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/about')
def about():
    #10.115.201.188
    #ip = get_domain_name_ip("usedvictoria.com")
    #nmap_output = get_nmap("-F",ip)
    #threading.Timer(20.0,about).start()
    nmap_output = get_devices_on_network("-sn", "10.0.0.1")
    arp_output = arp("-a")
    formatted_arp_output = arp_output.splitlines()
    print("formatted_arp_output",formatted_arp_output)
    #print(formatted_arp_output)
    ips = format_to_get_ip(formatted_arp_output[:-2])
    print("ips",ips)
    macs = format_to_get_mac(formatted_arp_output[:-2])
    vendors = get_vendor_by_mac(macs)
    number_of_devices = createList(0,len(macs)-1)
    open_ports = 'close'#get_open_port_details(ips)

    #scenario 1:
    #newips = [1,2,3,4,5] oldips = [1,2,3]
    #scenario 2:
    #newips = [1,2,3,4,6] oldips = [1,2,3,4,7]
    #scenario 3:
    #newips = [1,2] oldips = [1,2,3,4,5]
    #newips = [1,7] oldips = [1,2,3,4,5]


    global temp_ip_list
    print('temp_ip_list',temp_ip_list)
    global old_ip_list
    if (set(old_ip_list) != set(ips)):
        identical_ips = False
        temp_ip_list = list(set(ips).difference(old_ip_list))
        old_ip_list = ips
    else:
        identical_ips = True
        temp_ip_list = ips
    return render_template('about.html', number_of_devices = number_of_devices, ips = ips, macs = macs, vendors = vendors, open_ports = open_ports, identical_ips = identical_ips, temp_ip_list = temp_ip_list)

#nmap -F -Pn ipaddress to find open ports
def get_correct_index(formatted_arp_output):
    """
    Gets the index of the ips that don't return with 'incomplete' from arp -a
    """
    ip_index = []
    index = 0
    for i in formatted_arp_output:
        if 'incomplete' not in i:
            ip_index.append(index)
        index +=1
    return ip_index

def format_to_get_ip(formatted_arp_output):
    ips = []
    ip_index = get_correct_index(formatted_arp_output)
    for i in ip_index:
        #ips.append(re.search('\(([^)]+)', arp_result[i]).groups(1)[0])
        ip_data = re.search('\(([^)]+)', formatted_arp_output[int(i)]) #Get the data between brackets ()
        print(10101010101)
        print(ip_data.group(1))
        print(20202020220)
        if 'incomplete' not in ip_data.group(1):
            ips.append(ip_data.group(1))
    return ips

def check_if_new_ip():

    pass

def format_to_get_mac(arp_result):
    macs = []
    for i in range(len(arp_result)):
        mac_data = re.search('at (.*) on', arp_result[i]) #Gets the string between at and on
        if 'incomplete' not in mac_data.group(1):
            macs.append(mac_data.group(1))
        print("mac",macs)
    return macs

def get_devices_on_network(options, ip_address):
    # threading.Timer(12.0, get_devices_on_network,(options, ip_address)).start()
    print("test")
    command = "ping " + "10.0.0.255"
    process = os.popen(command)
    command = "nmap " + options + " " + ip_address + "/24"
    process = os.popen(command)
    command = "arp -a -n"
    process = os.popen(command)
    arp_output = str(process.read())
    print(arp_output)
    return arp_output

def get_domain_name_ip(url):
    ip = socket.gethostbyname(url)
    return ip

def get_nmap(options, ip_address):
    #nmap -options -ip
    nmap_output = ""
    command = "nmap " + options + " " + ip_address
    process = os.popen(command)
    nmap_output = str(process.read())
    return nmap_output

def arp(options):
    command = "arp " + options
    process = os.popen(command)
    arp_output = str(process.read())
    return arp_output

def ping(ip):
    command = "ping " + ip
    process = os.popen(command)
    ping_output = str(process.read())
    return ping_output

def banner_grabber():
    s = socket.socket()
    ip = "10.0.0.1"
    port = str(22)
    s.connect((ip,int(port)))
    print(s.recv(1024))

def createList(r1, r2):
    return [item for item in range(r1, r2+1)]

def get_vendor_by_mac(mac_address):
    #API base url,you can also use https if you need
    url = "http://macvendors.co/api/"
    #Mac address to lookup vendor from
    #mac_address = "74:E5:43:D2:8A:81"
    vendor = []
    for i in range(len(mac_address)):
        request = urllib2.Request(url+mac_address[i], headers={'User-Agent' : "API Browser"})
        response = urllib2.urlopen( request )
        #Fix: json object must be str, not 'bytes'
        reader = codecs.getreader("utf-8")
        obj = json.load(reader(response))
        #print(obj)
        if ('company' in obj['result'].keys()):
            vendor.append(obj['result']['company'])
        else:
            vendor.append("Not Found")
    return vendor

def get_open_port_details(ip_addresses):
    single_open_port_details = []
    open_port_details = []
    for i in range(len(ip_addresses)):
        command = "nmap " + "-F -Pn" + " " + ip_addresses[i]
        process = os.popen(command)
        single_open_port_details = str(process.read()).splitlines()
        print(single_open_port_details)
        if len(single_open_port_details) <= 6:
            open_port_details.append("No ports open")
        else:
            open_port_details.append(single_open_port_details[5:-2])
    return open_port_details

def virus_total_scan():
    url = 'https://www.virustotal.com/vtapi/v2/ip-address/report'
    params = {'apikey':'ce73360a9d0367f3bffdb01774fcddf28c02366ad05c812cff2ac6e09377aa3b','ip':'104.219.54.206'}
    response = requests.get(url, params=params)
    print(response.json())
    return

def hello_world():
    #threading.Timer(2.0, hello_world).start() # called every minute
    print("Hello, World!")

def malware_analysis():
    data = pd.read_csv("/Users/markshaio/Desktop/Personal Projects/Cyber/MicrosoftMalwarePredictionData/train.csv")
    df = data[['ProductName','EngineVersion','AppVersion','DefaultBrowsersIdentifier','AVProductStatesIdentifier','HasTpm','CountryIdentifier','Platform','Processor','OsVer','OsBuild','IsProtected','SMode','Firewall','Census_PrimaryDiskTotalCapacity','Census_IsVirtualDevice','Wdft_IsGamer']]
    print(df.head())

if __name__ == "__main__":
    # malware_analysis()
    # virus_total_scan()
    result = get_devices_on_network("-sn", "10.0.0.1")
    hello_world()
    app.run(debug=False)
