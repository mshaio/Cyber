from network_scan import NetworkScanner
from network_scan import get_local_ip
from cyber_scrape import CyberScrape, PostgresCyberScrape
from app_scan import ApplicationScan

#Global variable
global temp_ip_list
temp_ip_list = []
global old_ip_list
old_ip_list = []

#Web framework imports
from flask import Flask, render_template

local_scanner = NetworkScanner(get_local_ip())
apps = ApplicationScan()

app = Flask(__name__)

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/about')
def about():
    #10.115.201.188
    #ip = get_domain_name_ip("usedvictoria.com")
    #nmap_output = get_nmap("-F",ip)
    #threading.Timer(20.0,about).start()
    arp_output = local_scanner.get_devices_on_network("-sn", "-a -n")
    ips = local_scanner.format_to_get_ip(arp_output)[:-2]
    macs = local_scanner.format_to_get_mac(arp_output)[:-2]

    for ip in ips:
        offline_ip = local_scanner.detect_failed_ping(ip)
        if offline_ip != None:
            offline_ip_index = ips.index(offline_ip)
            ips.pop(offline_ip_index)
            macs.pop(offline_ip_index)
        

    vendors = local_scanner.get_vendor_by_mac(macs)
    mobile, iphone, android = NetworkScanner.detect_mobile(ips)
    # vendors = get_vendor_by_mac(macs)
    number_of_devices = createList(0,len(macs)-1)
    open_ports = 'close'#get_open_port_details(ips)

    nvd_nist_cve = CyberScrape(CyberScrape.NVD_NIST_URL,"div","id","latestVulnsArea")
    nvd_nist_scraped_cyber_data = nvd_nist_cve.scrape_url()
    latest_20_vulns = nvd_nist_cve.nvd_nist_vulns(nvd_nist_scraped_cyber_data)
    latest_20_severity = nvd_nist_cve.vulns_level(latest_20_vulns)
    latest_20_severity
    exposed_to_new_vuln = nvd_nist_cve.detect_vuln_keywords(CyberScrape.ALL_KEYWORDS, latest_20_vulns)

    postgres_sec_info = PostgresCyberScrape(PostgresCyberScrape.POSTGRES_SEC_URL, "table", "class", "table table-striped")
    postgres_sec_info_scraped = postgres_sec_info.scrape_url()
    print(postgres_sec_info.postgres_vulns(postgres_sec_info_scraped))

    print(check_local_postgres_vulns(apps.postgres_scan(),postgres_sec_info.postgres_vulns(postgres_sec_info_scraped)))
    #scenario 1:
    #newips = [1,2,3,4,5] oldips = [1,2,3]
    #scenario 2:
    #newips = [1,2,3,4,6] oldips = [1,2,3,4,7]
    #scenario 3:
    #newips = [1,2] oldips = [1,2,3,4,5]
    #newips = [1,7] oldips = [1,2,3,4,5]


    global temp_ip_list
    print('temp_ip_list',temp_ip_list)
    global old_ip_list
    if (set(old_ip_list) != set(ips)):
        identical_ips = False
        temp_ip_list = list(set(ips).difference(old_ip_list))
        old_ip_list = ips
    else:
        identical_ips = True
        temp_ip_list = ips
    return render_template('about.html', number_of_devices = number_of_devices, ips = ips, macs = macs, vendors = vendors, open_ports = open_ports, identical_ips = identical_ips, temp_ip_list = temp_ip_list, mobile = mobile, exposed_to_new_vuln=exposed_to_new_vuln)

def createList(r1, r2):
    return [item for item in range(r1, r2+1)]

def check_local_postgres_vulns(local_scan_result, cyber_scrape_vulns):
    """
    Checks if the local machine has a vulnerable postgres version
    Args:
        local_scan_result (string): postgres version on the machine
        cyber_scrape_vulns (dict): Vulnerabilities containing, cve, affected version, fixed version, cvss and vulnerability descriptions.

    Returns:
        vulns_detected (dict): Detected vulnerabilities
        eg: {'postgres_cve': 'CVE-2020-1720', 'postgres_cvss': '3.1', 'postgres_descript': 'ALTER ... DEPENDS ON EXTENSION is missing authorization checks.'}
    """
    index = 0
    found_index = False
    vulns_detected = {}
    if local_scan_result.split()[0] == "postgres":
        app_version = local_scan_result.split()[-1]

    for vuln_ver in cyber_scrape_vulns["postgres_fixed_ver"]:
        for i in vuln_ver.split():
            if i == app_version:
                found_index = True
                vulns_detected["postgres_cve"] = cyber_scrape_vulns["postgres_cve"][index]
                vulns_detected["postgres_cvss"] = cyber_scrape_vulns["postgres_cvss"][index]
                vulns_detected["postgres_descript"] = cyber_scrape_vulns["postgres_descript"][index]
                break
        index +=1
    return vulns_detected

# def get_domain_name_ip(url):
#     ip = socket.gethostbyname(url)
#     return ip

# def banner_grabber():
#     s = socket.socket()
#     ip = "10.0.0.1"
#     port = str(22)
#     s.connect((ip,int(port)))
#     print(s.recv(1024))

# def virus_total_scan():
#     url = 'https://www.virustotal.com/vtapi/v2/ip-address/report'
#     params = {'apikey':'ce73360a9d0367f3bffdb01774fcddf28c02366ad05c812cff2ac6e09377aa3b','ip':'104.219.54.206'}
#     response = requests.get(url, params=params)
#     print(response.json())
#     return

# def hello_world():
#     #threading.Timer(2.0, hello_world).start() # called every minute
#     print("Hello, World!")

# def malware_analysis():
#     data = pd.read_csv("/Users/markshaio/Desktop/Personal Projects/Cyber/MicrosoftMalwarePredictionData/train.csv")
#     df = data[['ProductName','EngineVersion','AppVersion','DefaultBrowsersIdentifier','AVProductStatesIdentifier','HasTpm','CountryIdentifier','Platform','Processor','OsVer','OsBuild','IsProtected','SMode','Firewall','Census_PrimaryDiskTotalCapacity','Census_IsVirtualDevice','Wdft_IsGamer']]
#     print(df.head())

if __name__ == "__main__":
    app.run(debug=False)
