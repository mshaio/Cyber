import os
import re
import urllib.request as urllib2
import json
import codecs

class NetworkScanner:
     
     BROADCAST_ADDR = "255"
     SUBNET = "/24"

     def __init__(self, ip_address, port=None):
         self.ip_address = ip_address
         self.port = port


     def get_devices_on_network(self, nmap_options, arp_options):
        """
        Retrieves the devices on the network via NMAP
        Args:
            nmap_options (string): The nmap flags
            arp_options (string): The arp flags

        Returns:
            arp_output (string): Arp output that contains the IPs and MACs
            eg: "? (10.0.0.110) at f0:18:98:e:3e:1c on en0 ifscope permanent [ethernet]
                 ? (10.0.0.118) at 10:30:25:6e:1a:95 on en0 ifscope [ethernet]"
        """
        # threading.Timer(12.0, get_devices_on_network,(options, ip_address)).start()
        THIRD_OCTET = 3
        first_3_ip_octet = self.ip_address.split(".")[:THIRD_OCTET]
        command = "ping " + first_3_ip_octet[0] + "." + first_3_ip_octet[1] + "." + first_3_ip_octet[2] + "." + NetworkScanner.BROADCAST_ADDR
        process = os.popen(command)
        command = "nmap " + nmap_options + " " + self.ip_address + NetworkScanner.SUBNET
        process = os.popen(command)
        command = "arp " + arp_options #"arp -a -n"
        process = os.popen(command)
        arp_output = str(process.read())[:-1] #Removes the space at the end
        # print(arp_output)
        return arp_output

     def get_correct_index(self, formatted_arp_output):
         """
         Gets the index of the ips that don't return with 'incomplete' from arp -a
         Args:
            formatted_arp_output (list(string)): arp output split by new line
            eg: ['? (10.0.0.1) at 5c:76:95:d2:29:56 on en0 ifscope [ethernet]', 
                '? (10.0.0.96) at e4:e7:49:c4:56:7e on en0 ifscope [ethernet]']

         Returns:
            ip_index (list(int)): Index of ip addresses that don't return 'incomplete' via an arp scan
         """
         ip_index = []
         index = 0
         for i in formatted_arp_output:
             if 'incomplete' not in i:
                 ip_index.append(index)
             index +=1
         return ip_index

     def format_to_get_ip(self, arp_output):
         """
         Formats the arp results to get the IPs. Uses regex to retrieve the content between ().
         Args: 
            arp_output (string): Arp output
         Returns:
            ips (list(string)): The list of ips on the network
            eg: ['10.0.0.1', '10.0.0.110', '10.0.0.118', '10.0.0.153', '10.0.0.255']
         """
         formatted_arp_output = arp_output.splitlines()
         ips = []
         ip_index = self.get_correct_index(formatted_arp_output)
         for i in ip_index:
             #ips.append(re.search('\(([^)]+)', arp_result[i]).groups(1)[0])
             ip_data = re.search('\(([^)]+)', formatted_arp_output[int(i)]) #Get the data between brackets ()
             if 'incomplete' not in ip_data.group(1):
                 ips.append(ip_data.group(1))
         return ips

     def format_to_get_mac(self, arp_output):
         """
         Formats the arp results to get the mac addresses. Uses regex to retrive the content between 'at' and 'on' strings
         Args:
            arp_output (string): Arp output
         Returns:
            macs (list(string)): A list of mac addresses on the network
            eg: ['5c:76:95:d2:29:56', 'f0:18:98:e:3e:1c']
         """
         formatted_arp_output = arp_output.splitlines()
         macs = []
         for i in range(len(formatted_arp_output)):
             mac_data = re.search('at (.*) on', formatted_arp_output[i]) #Gets the string between at and on
             if 'incomplete' not in mac_data.group(1):
                 macs.append(mac_data.group(1))
             # print("mac",macs)
         return macs

     def get_vendor_by_mac(self, mac_addresses):
         """
         Get the vendor from the mac address
         Args:
            mac_addresses (list(string)): A list of mac addresses found on the network
         Returns:
            vendors (list(string)): A list of vendors for the devices on the network
            eg: ['Technicolor CH USA Inc.', 'Apple, Inc.']
         """
         #API base url,you can also use https if you need
         url = "http://macvendors.co/api/"
         #Mac address to lookup vendor from
         #mac_address = "74:E5:43:D2:8A:81"
         vendors = []
         for i in range(len(mac_addresses)):
             request = urllib2.Request(url+mac_addresses[i], headers={'User-Agent' : "API Browser"})
             response = urllib2.urlopen( request )
             #Fix: json object must be str, not 'bytes'
             reader = codecs.getreader("utf-8")
             obj = json.load(reader(response))
             #print(obj)
             if ('company' in obj['result'].keys()):
                 vendors.append(obj['result']['company'])
             else:
                 vendors.append("Not Found")
         return vendors

def get_local_ip():
    """
    Find the ip address of the machine running the network scan
    Args: 
        None
    Returns:
        ip_address (string): The ip address of the machine that's running the network scan
    """
    command = "ipconfig getifaddr en0" #Linux is hostname -I
    process = os.popen(command)
    ip_address = str(process.read())[:-1] #Removes the space at the end
    return ip_address



# local_scanner = NetworkScanner(get_local_ip())
# arp_result = local_scanner.get_devices_on_network("-sn", "-a -n")
# ips_on_network = local_scanner.format_to_get_ip(arp_result)
# mac_addr_on_network = local_scanner.format_to_get_mac(arp_result)
# print(arp_result)
# print(ips_on_network)
# print(mac_addr_on_network)
# vendor_names = local_scanner.get_vendor_by_mac(mac_addr_on_network[:-2])
# print(vendor_names)
# print(NetworkScanner("10.0.0.1").get_vendor_by_mac(mac_addr_on_network[:-2]))